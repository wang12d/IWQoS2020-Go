package pkg

import (
	"crypto/aes"
	"encoding/hex"
	"fmt"
	"log"
	"math/big"
	"nju/cosec/heng/pkg/utils"

	"github.com/ethereum/go-ethereum/crypto"
)

const (
	gStr = "2141434891434191460597654106285009794456474073127443963580690795002163321265105245635441519012876162226508712450114295048769820153232319693432987768769296824615642594321423205772115298200265241761445943720948512138315849294187201773718640619332629679913150151901308086084524597187791163240081868198195818488147354220506153752944012718951076418307414874651394412052849270568833194858516693284043743223341262442918629683831581139666162694560502910458729378169695954926627903314499763149304778624042360661276996520665523643147485282255746183568795735922844808611657078638768875848574571957417538833410931039120067791054495394347033677995566734192953459076978334017849678648355479176605169830149977904762004245805443987117373895433551186090322663122981978369728727863969397652199851244115246624405814648225543311628517631088342627783146899971864519981709070067428217313779897722021674599747260345113463261690421765416396528871227"
	pStr = "3268470001596555685058361448517594259852327289373621024658735136696086397532371469771539343923030165357102680953673099920140531685895962914337283929936606946054169620100988870978124749211273448893822273457310556591818639255714375162549119727203843057453108725240320611822327564102565670538516259921126103868685909602654213513456013263604608261355992328266121535954955860230896921190144484094504405550995009524584190435021785232142953886543340776477964177437292693777245368918022174701350793004000567940200059239843923046609830997768443610635397652600287237380936753914127667182396037677536643969081476599565572030244212618673244188481261912792928641006121759661066004079860474019965998840960514950091456436975501582488835454404626979061889799215263467208398224888341946121760934377719355124007835365528307011851448463147156027381826788422151698720245080057213877012399103133913857496236799905578345362183817511242131464964979"
	qStr = "93911948940456861795388745207400704369329482570245279608597521715921884786973"
)

func padding(number int) string {
	return fmt.Sprintf("%064x", number)
}

// BuildIndex builds task index according to the description of paper for each broker
func BuildIndex(brokers *map[string][][]byte, brokerLocalState *[]map[string]int, brokerKeys []BrokerKey) map[string][]byte {
	numberOfBrokers := len(*brokers)
	g, p, q := new(big.Int), new(big.Int), new(big.Int)
	g.SetString(gStr, 10)
	p.SetString(pStr, 10)
	q.SetString(qStr, 10)
	taskIndex := make(map[string][]byte)
	intOp, tmp := new(big.Int), new(big.Int)
	for i := 0; i < numberOfBrokers; i++ {
		for key, val := range *brokers {
			keyNumber, Fb1 := new(big.Int), new(big.Int)
			keyNumber.SetString(key, 10)
			Fb1.SetString(brokerKeys[i].Fb1, 10)
			tmp.Mul(keyNumber, Fb1)
			tmp.Mod(tmp, q)
			backdoor := intOp.Exp(g, tmp, p)
			trap := hex.EncodeToString([]byte(backdoor.String()))
			for _, block := range val {
				trapdoor := trap + padding((*brokerLocalState)[i][key])
				(*brokerLocalState)[i][key]++
				label := crypto.Keccak256([]byte(trapdoor))
				cipher, err := aes.NewCipher([]byte("1234512345123451"))
				if err != nil {
					log.Fatalln("AES create new cipher error")
				}
				C := utils.AESECBEncryption(cipher, block)
				minLen := min(len(C), len(label))
				P := make([]byte, minLen)
				for i := 0; i < minLen; i++ {
					P[i] = C[i] ^ label[i]
				}
				taskIndex[hex.EncodeToString(label)] = P
			}
		}
	}
	return taskIndex
}

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}
